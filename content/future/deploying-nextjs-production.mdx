---
title: "Deploying Next.js to Production: From Vercel to Self-Hosted"
excerpt: "A practical guide to deploying Next.js applications, comparing Vercel, Docker, and self-hosted options. Real costs, performance metrics, and lessons learned."
date: "2025-10-18"
author: "Nischal Timalsina"
tags: ["deployment", "devops", "nextjs", "vercel", "docker"]
published: true
---

# Deploying Next.js to Production: From Vercel to Self-Hosted

When One of my Projects hit 1,000 active users, our Vercel bill went from $20/month to $400/month. Time to explore alternatives.

Here's what I learned deploying Next.js apps across different platforms.

## The Options

### 1. Vercel (The Official Platform)

**Pros:**
- Zero-config deployment
- Automatic preview deployments
- Edge functions built-in
- Excellent developer experience
- Automatic SSL/CDN

**Cons:**
- Expensive at scale ($20/100k requests after free tier)
- Vendor lock-in (some features are Vercel-only)
- Limited control over infrastructure

**When to use:**
- You're just starting out
- Fast iteration is more valuable than cost optimization
- You want zero DevOps overhead

### 2. Docker + VPS (DigitalOcean, AWS EC2, etc.)

**Pros:**
- Full control
- Predictable costs
- Can optimize for your specific needs
- Easy to migrate between providers

**Cons:**
- Requires DevOps knowledge
- Manual scaling
- You manage SSL, CDN, monitoring

**When to use:**
- Predictable traffic patterns
- Cost-conscious
- Need custom infrastructure

### 3. Kubernetes (AWS EKS, GCP GKE)

**Pros:**
- Horizontal scaling
- High availability
- Professional-grade infrastructure

**Cons:**
- Extremely complex
- Expensive (cluster + nodes)
- Overkill for most apps

**When to use:**
- Large-scale applications (10,000+ users)
- Multiple services that need orchestration
- You have a dedicated DevOps team

## My Choice: Docker on DigitalOcean

For my project, I went with Docker on DigitalOcean App Platform. Here's why:

**Cost comparison (1,000 active users):**
- Vercel: ~$400/month
- DigitalOcean: $60/month (App Platform) or $12/month (Droplet)
- AWS: ~$150/month (EC2 + RDS + misc)

## Docker Setup for Next.js

### Dockerfile

```dockerfile
# Build stage
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci

# Copy source code
COPY . .

# Build app
RUN npm run build

# Production stage
FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production

# Copy necessary files
COPY --from=builder /app/next.config.js ./
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

EXPOSE 3000

CMD ["node", "server.js"]
```

### next.config.js

Enable standalone output:

```typescript
// next.config.ts
const nextConfig = {
  output: 'standalone',
  // ... other config
}

export default nextConfig
```

### docker-compose.yml

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
      - NEXTAUTH_URL=${NEXTAUTH_URL}
    restart: unless-stopped
    depends_on:
      - mongodb

  mongodb:
    image: mongo:7
    ports:
      - "27017:27017"
    environment:
      - MONGO_INITDB_ROOT_USERNAME=${MONGO_USER}
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_PASSWORD}
    volumes:
      - mongodb_data:/data/db
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certbot/conf:/etc/letsencrypt:ro
      - ./certbot/www:/var/www/certbot:ro
    depends_on:
      - app
    restart: unless-stopped

volumes:
  mongodb_data:
```

### nginx.conf

```nginx
events {
    worker_connections 1024;
}

http {
    upstream app {
        server app:3000;
    }

    server {
        listen 80;
        server_name example.com www.example.com;

        location /.well-known/acme-challenge/ {
            root /var/www/certbot;
        }

        location / {
            return 301 https://$host$request_uri;
        }
    }

    server {
        listen 443 ssl;
        server_name example.com www.example.com;

        ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;

        location / {
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

## SSL with Let's Encrypt

### Setup script

```bash
#!/bin/bash

# init-letsencrypt.sh
domains=(example.com www.example.com)
email="your-email@example.com"
staging=0 # Set to 1 for testing

# Start nginx
docker-compose up -d nginx

# Download recommended TLS parameters
curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf > ./certbot/conf/options-ssl-nginx.conf
curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot/certbot/ssl-dhparams.pem > ./certbot/conf/ssl-dhparams.pem

# Get certificate
docker-compose run --rm certbot certonly --webroot \
  --webroot-path=/var/www/certbot \
  --email $email \
  --agree-tos \
  --no-eff-email \
  $([ $staging = 1 ] && echo "--staging") \
  $(for domain in "${domains[@]}"; do echo "-d $domain"; done)

# Reload nginx
docker-compose exec nginx nginx -s reload
```

### Auto-renewal

Add to crontab:

```bash
0 12 * * * cd /path/to/app && docker-compose run --rm certbot renew && docker-compose exec nginx nginx -s reload
```

## CI/CD with GitHub Actions

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: yourname/appointree:latest
          cache-from: type=registry,ref=yourname/appointree:buildcache
          cache-to: type=registry,ref=yourname/appointree:buildcache,mode=max

      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /app
            docker-compose pull
            docker-compose up -d
            docker system prune -f
```

## Performance Optimization

### 1. Caching Strategy

```nginx
# Static assets - cache for 1 year
location /_next/static {
    proxy_pass http://app;
    proxy_cache_valid 200 365d;
    add_header Cache-Control "public, immutable";
}

# Images - cache for 1 month
location ~* \.(jpg|jpeg|png|gif|ico|svg|webp)$ {
    proxy_pass http://app;
    proxy_cache_valid 200 30d;
    add_header Cache-Control "public";
}

# API routes - no cache
location /api {
    proxy_pass http://app;
    add_header Cache-Control "no-cache, no-store, must-revalidate";
}
```

### 2. Gzip Compression

```nginx
gzip on;
gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
gzip_min_length 1000;
gzip_comp_level 6;
```

### 3. Connection Pooling

```typescript
// lib/db/mongodb.ts
import { MongoClient } from 'mongodb'

let client: MongoClient | null = null

export async function connectToDatabase() {
  if (client) {
    return client
  }

  client = new MongoClient(process.env.MONGODB_URI!, {
    maxPoolSize: 50,
    minPoolSize: 10,
    maxIdleTimeMS: 30000,
  })

  await client.connect()
  return client
}
```

## Monitoring

### 1. Health Check Endpoint

```typescript
// app/api/health/route.ts
import { connectToDatabase } from '@/lib/db'

export async function GET() {
  try {
    // Check database
    const db = await connectToDatabase()
    await db.db().admin().ping()

    return Response.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
    })
  } catch (error) {
    return Response.json(
      {
        status: 'unhealthy',
        error: error.message
      },
      { status: 503 }
    )
  }
}
```

### 2. Docker Health Check

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/api/health', (res) => { process.exit(res.statusCode === 200 ? 0 : 1); });"
```

### 3. Uptime Monitoring

Use UptimeRobot or similar:
- Monitor `/api/health` every 5 minutes
- Alert via email/Slack if down
- Free tier is usually sufficient

## Backup Strategy

```bash
#!/bin/bash
# backup.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups"

# Backup MongoDB
docker-compose exec -T mongodb mongodump \
  --archive="/dump/backup_${DATE}.archive" \
  --gzip

# Backup to S3 (optional)
aws s3 cp \
  "${BACKUP_DIR}/backup_${DATE}.archive" \
  s3://your-bucket/backups/

# Delete old backups (keep last 7 days)
find $BACKUP_DIR -name "backup_*.archive" -mtime +7 -delete
```

Add to crontab:
```bash
0 2 * * * /path/to/backup.sh
```

## Cost Breakdown

### Vercel (Pro Plan)
- Base: $20/month
- 100k requests: $0
- 200k requests: $40
- 500k requests: $200
- 1M requests: $400
- **Total at 1M requests: $420/month**

### DigitalOcean Droplet
- 2GB RAM, 1 vCPU: $12/month
- Managed MongoDB: $15/month
- Backups: $3/month
- **Total: $30/month** (unlimited requests)

### DigitalOcean App Platform
- Basic: $12/month
- Professional: $60/month (auto-scaling)
- Managed DB: $15/month
- **Total: $75/month** (scales automatically)

## When to Stay on Vercel

Don't move if:
- Your bill is < $100/month
- Fast iteration is critical
- You don't have DevOps experience
- You're using Vercel-specific features (Edge functions, ISR)

Vercel's value isn't just hosting â€“ it's the developer experience and zero-config deployment.

## Conclusion

**For my project:**
- Started on Vercel ($20/month)
- Grew to 1,000 users ($400/month on Vercel)
- Migrated to DigitalOcean App Platform ($60/month)
- Saved $340/month or $4,080/year

But it wasn't just about cost. I also gained:
- Better understanding of deployment
- More control over infrastructure
- Ability to optimize for our specific needs


> Start with Vercel. Move to self-hosted when costs justify the DevOps overhead. For most apps, that's around the $100-200/month mark.
